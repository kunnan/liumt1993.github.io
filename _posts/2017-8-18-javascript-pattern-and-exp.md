---
layout: post
title:  "《Javascript设计模式与实践》笔记"
date:   2017-8-18
categories: my blog
---

## 前言：

笔记内容几乎都是摘抄原书，目的有二，一是手写一遍加深记忆，二是做为记忆钩子方便复习。

这本书看完后受益很大，第一是知道了很多代码为什么这么写，第二是对如何编写优雅的代码有了新的认识。作者非常用心，文风幽默通俗易懂，书中包含大量实践示例和设计模式的应用场景介绍，真正的让人学以致用。

### 动态类型和静态类型语言

编程语言按照类型大体分为两类，静态类型和动态类型。

静态类型的语言在编译时就已确定变量的类型。

动态类型语言要在程序运行时，变量被赋值后才能确定类型。

静态类型的优点：编译时就能发现变量类型的错误。因为类型的指定，编译器可以更好的识别这些信息，提高程序执行效率。

缺点：麻烦，对人的思维模式不友好。

动态类型的优点：方便，简洁，符合人的思维习惯。

缺点：无法保证变量类型，类型错误不会在编译期间暴露，编译器需要花时间去分析变量，降低编译效率。


JS是一门动态类型的语言。


### 鸭子类型 duck typing

鸭子类型指导我们只关注对象的行为，而不关注对象本身。


### 多态

多态：同一操作在面对不同对象时，可以产生不同的解释和执行结果。

多态的思想是将[做什么]和[谁去做以及怎么做]分离开来，也就是将[不变的事物]与[可变的事物]分离开来。把不变的分离出来，把可变的封装起来，这让程序变得可扩展，也符合开放-封闭原则。对于修改代码来说，仅仅增加代码就可以完成同样的功能，这显然更优雅和安全。

静态类型语言向上转型：当给一个类变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类。

而作为动态类型语言的JS，JS的多态性是与生俱来的。因为JS是鸭子类型的，所以不需要去考虑“类型耦合”的问题。

多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。

### 封装

封装的目的是将信息隐藏。

### 原型模式

这一节纠正和清晰和我对原型模式的理解。

每个对象都有一个`__proto__`的隐藏属性，`__proto__`属性默认会指向它的构造器函数的原型对象`{Constructor}.prototype`

JS中每个对象都包含一个隐藏的`[[prototype]]`对象，可以通过`__proto__`来访问`[[prototype]]`对象。

使用`prototype`来实现继承，只需要把对象的`prototype`指向你想要继承的对象即可。

可以使用`Object.create()`来完成原型继承

### 闭包

变量生命周期

全局变量的生命周期是永久的，除非退出页面，否则是不会被销毁的。

而局部变量的生命周期是在函数执行完毕之后，变量就会被销毁。

但是当一个作用域中的变量被返回，并且被外部作用域所使用时，这个作用域中的局部变量的生命周期会被延长。而这个作用域，以及所返回函数就组成了一个叫做闭包的东西。

闭包本身并不会造成内存泄漏，闭包返回的局部变量生命周期被延长，使它们像全局变量一样会一直存在于内存中，但这并不会导致内存泄漏。

而闭包可能导致内存泄漏的情况是，利用闭包造成循环引用。

闭包可以用来封装私有信息

闭包可以用来延长局部变量的生命周期


### 高阶函数

高阶函数是指至少满足两个条件之一的函数：

1.函数可以作为参数被传递

比较常见的场景就是函数作为回调函数使用

2.函数可以作为返回值输出

使用函数当作返回值，可以巧妙的延续运算过程。

### currying

`currying`又称部分求值。一个`currying`函数首先会接受一些参数，接受了参数之后，该函数并不会立即求值，而是继续返回另外一个函数，而刚才传入的参数在函数形成的闭包中被保存起来。带到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。

### uncurrying

`uncurrying`使方法的使用不局限与对象本身，利用`uncurrying`方法可以随意借用其他对象的方法。`uncurrying`的作用就是泛化`this`。

### 函数节流

当函数的调用频率过高时，可以考虑进行函数节流。

### 分时函数

当需要执行大量操作时，可以对操作进行分时，使得占用的内存被分摊不至于造成内存拥堵。

### 惰性加载函数

避免函数的无意义加载和重复加载。

### 单例模式

定义：保证一个类仅有一个实例，并提供一个它的全局访问点。

### 策略模式

定义：定义一系列算法，把它们一个个封装起来，并且使用它们可以相互替换。

一个基于策略模式的程序至少由两部分组成。
第一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。
第二部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context中要维持对某个策略对象的引用。


策略模式的实现并不复杂，关键是如何从策略模式的实现背后，找到封装变化、委托和多态性这些思想的价值。

### 代理模式

代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。

代理模式的关键是，当客户不方便访问一个对象或者不满足需要的时候，提供一个替身对象来控制这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理后，再把请求转交给本体对象。

#### 虚拟代理

虚拟代理会为本体创建一个替身，当客户访问时，访问的是这个的替身，而替身会把访问请求再转交给本体。

#### 缓存代理

缓存代理的作用，是为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递的参数和之前一致，就可以直接返回存储的结果，避免再次运算。

代理模式的意义：

+ 符合单一职责原则

### 迭代器模式

迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。

### 观察者模式

观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。

观察者模式的优点，一是时间上的解耦，二是对象之间的解耦。

### 命令模式

消除请求发送者和接受者之间的耦合。

命令模式可以完成撤销、排队等功能。

### 组合模式

组合模式将对象组合成树形结构，以标识“部分-整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。

### 模板方法模式

模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。把不变的部分封装到模板类当中，再通过子类来实现变化的部分，这样就可以轻易通过子类类扩展程序。在JS中可以通过高阶函数来实现模板模式。

### 享元模式

享元模式要求将对象的属性划分为内部状态和外部状态。享元模式的目标是尽量减少共享对象的数量。

如何划分内外部状态：

+ 内部状态存储于对象内部。
+ 内部状态可以被一些对象共享
+ 内部状态独立于具体的场景，通常不会变化
+ 外部状态取决于具体的场景，并且根据场景而变化，外部状态不能被共享。


### 职责链模式

使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，我都知道有一个对象处理它为止。


### 中介者模式

中介者模式的作用是解除对象和对象之间的紧耦合关系。增加中介者后，所有的对象都通过中介者来交互，而不是对象和对象之间直接交互。让对象和对象之间处于松耦合的状态。

中介者模式的缺点是系统会新增一个中介者对象，而对象之间交互的复杂性会转义成中介者对象的复杂性，会使中介者难以维护。

### 装饰者模式

装饰者模式可以在不改变对象的基础上动态的给对象添加职责。

装饰者模式的缺点是过度的使用会不断地延长函数的作用域，出现性能问题。

装饰者模式和代理模式的区别是它们的意图和设计目的。代理模式是不方便访问对象或不符合需要时，给用户提供一个替代者来访问。

代理模式强调的是一种关系，这种代理关系一开始就是确定的。而装饰者模式则是动态的给对象添加职责。

### 状态模式

状态模式定义了状态与行为之间的关系，并将他们封装在一个类里。通过增加新的状态类，很容易增加很的状态和转换。

### 适配器模式

解决接口不兼容的问题，可以很好的解决接口不兼容的问题。

### 设计原则

+ 单一职责原则：一个对象（方法）只做一件事
+ 最少知识原则：软件实体应该尽量少地与其他实体发生相互作用
+ 开放封闭原则：在不改动原有代码的前提下增加功能
